{
  "hash": "56d2378bb2148ae3628945eca7aa9485",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Vectors\"\n---\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n:::\n\n\n[Vectors]{.defword title=\"A **vector** is an ordered sequence of values.\"} are sequences of numbers. The notation for vectors is not always applied consistently, but often vectors are topped with an arrow (or are bold lowercase letters), and the elements are listed in parentheses and separated by commas. A vector $\\vec{x}$ with elements 4 and 3 would be notated like so:\n\n$$\n\\vec{x}=\\left(4,3\\right)\n$$\n\n\nThe [vector length]{.defword title=\"A vector's **length** is the number of elements the vector contains.\"} refers to how many elements it has, not its magnitude. So a 2-element vector like $(x_1,x_2)$ has a length of 2.\n\nA sequence of indeterminate length $n$, would be notated like so\n\n$$\n\\vec{x}=\\left(x_1,x_2,\\ldots,x_n\\right)\n$$\n\n\n## Making vectors in R\n\nR is a peculiar peculiar language in that almost every object created in R is ultimately a vector of some kind or another. Here we are concerned with vectors made with real numbers (i.e., positive and negative numbers that can have decimals).[R can create vectors from many other types of data (e.g., integers, complex numbers, logical values, text, and raw binary numbers). A more advanced discussion about vectors in R can be found [here](https://adv-r.hadley.nz/vectors-chap.html). ]{.column-margin}\n\n### Making vectors with the `c` function\n\nVectors in R are created in many ways, but the most common way to join vector elements is with the `c` function. The `c` function \"combines\" (or [concatenates]{.defword title=\"To **concatenate** is to link things together in a chain or series.\"}) elements into a vector. For example, to combine 3 and 5:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(3, 5)\n```\n:::\n\n\n::: {.callout-note title=\"You Try\"}\n\nCreate a vector `x` with values 2 and 6.\n\n```{webr-r}\n#| label: ex-vector\n#| echo: true\nx <- c(_, _)\nx\n```\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nx <- c(2, 6)\n```\n\n\n\n</details>\n:::\n\n\n:::\n\n\n### Making vector sequences with the `:` operator\n\nYou can make sequential integer sequences with the `:` operator. To make a sequence from 1 to 5:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\n1:5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\nTo make a decreasing vector from 4 to 0:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\n4:0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 3 2 1 0\n```\n\n\n:::\n:::\n\n\n::: {.callout-note title=\"You Try\"}\n\nCreate a sequence of integers from 5 to 11 with the `:` operator.\n\n```{webr-r}\n#| label: ex-colon\n_:_\n```\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\n5:11\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  5  6  7  8  9 10 11\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n:::\n\n### Making vector sequences with `seq` function\n\nThe `seq` function allows for sequences of any interval or length.\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nseq(1,5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\nDecreasing from 5 to 1:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nseq(5,1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 4 3 2 1\n```\n\n\n:::\n:::\n\n\nThe `by` argument specifies the interval between elements. Here we specify a sequence from 0 to 1 by .1 intervals:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nseq(0, 1, 0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0\n```\n\n\n:::\n:::\n\n\nFor decreasing sequences, the `by` argument needs to be negative:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nseq(5, 3, -0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.0 4.5 4.0 3.5 3.0\n```\n\n\n:::\n:::\n\n\n::: {.callout-note title=\"You Try\"}\n\nCreate a sequence of integers from 3 to 6 with the `seq` function.\n\n```{webr-r}\n#| label: ex-colon\nseq(_,_)\n```\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nseq(3, 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4 5 6\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\nCreate a sequence of even integers from 2 to 10 with the `seq` function.\n\n```{webr-r}\n#| label: ex-even\nseq(_,_,_)\n```\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nseq(2, 10, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  4  6  8 10\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n\nCreate a decreasing sequence of integers from 6 to 3 with the `seq` function.\n\n```{webr-r}\n#| label: ex-decreasing\nseq(_,_)\n```\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nseq(6, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6 5 4 3\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\nCreate a decreasing sequence of numbers from 1 to -1 decreasing by increments of 0.2.\n\n```{webr-r}\n#| label: ex-decreasing2\nseq(_,_,_)\n```\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nseq(1, -1, -0.2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1.0  0.8  0.6  0.4  0.2  0.0 -0.2 -0.4 -0.6 -0.8 -1.0\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n:::\n\n## Selecting Specific Elements in a Vector\n\nIn R, there are several ways to select elements in a vector---by position, by condition, and by name.\n\n### Selecting by Position\n\nSuppose we have a vector with 5 elements:\n\n$$\\vec{x}=\\left(10,20,30,40,50\\right)$$\n\nFirst I define $\\vec{x}$\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- seq(10, 50, 10)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 20 30 40 50\n```\n\n\n:::\n:::\n\n\nThe 3rd element, 30, can be selected like so:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nx[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 30\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-note title=\"You Try\"}\n\nSelect the 4th element of `x`.\n\n```{webr-r}\n#| context: setup\nx <- seq(10, 50, 10)\nA <- matrix(1:12, nrow = 3, byrow = TRUE)\n```\n\n```{webr-r}\n#| label: ex-fourth\nx <- seq(10, 50, 10)\nx[_]\n```\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nx[4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 40\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n:::\n\n\nIf I want both the 3rd and 5th elements, I use a vector inside the square brackets:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nx[c(3, 5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 30 50\n```\n\n\n:::\n:::\n\n\n::: {.callout-note title=\"You Try\"}\n\nSelect first and fourth element of `x`.\n\n```{webr-r}\n#| label: ex-firstforth\nx <- seq(10, 50, 10)\nx[_]\n```\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nx[c(1, 4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 40\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n:::\n\n\n\n### Selecting by Condition\n\nR can select elements meeting any condition that evaluates to the logical value of `TRUE`. For example, which values of $\\vec{x}$ are greater than 35?\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nx > 35\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n\nThis creates a vector of 5 elements that are either `TRUE` or `FALSE`. We can select just the elements for which the condition is `TRUE` like so:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nx[x > 35]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 40 50\n```\n\n\n:::\n:::\n\n\n::: {.callout-note title=\"You Try\"}\n\nSelect elements of `x` less than 15.\n\n```{webr-r}\n#| label: ex-selectless\nx <- seq(10, 50, 10)\nx[_]\n```\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nx[x < 15]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n:::\n\n\n### Selecting by Name\n\nIn R, vector elements can have names. We can assign them directly like this:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(a = 1, b = 2, c = 3, d = 4, e = 5)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na b c d e \n1 2 3 4 5 \n```\n\n\n:::\n:::\n\n\nWe can also assign names using the `names` function:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 1:5\nx_names <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\nnames(x) <- x_names\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na b c d e \n1 2 3 4 5 \n```\n\n\n:::\n:::\n\n\nWe can select specific named elements like so:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nx[c(\"a\", \"d\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na d \n1 4 \n```\n\n\n:::\n:::\n\n\nWe can select them in any order:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nx[c(\"d\", \"a\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nd a \n4 1 \n```\n\n\n:::\n:::\n\n\nWe can even have repeats:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nx[c(\"a\", \"a\", \"b\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na a b \n1 1 2 \n```\n\n\n:::\n:::\n\n\n::: {.callout-note title=\"You Try\"}\n\nSelect elements `b` and `a` of `x`, in that order .\n\n```{webr-r}\n#| label: ex-selectnames\nx <- c(a = 1, b = 2, c = 3, d = 4, e = 5)\nx[_]\n```\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\nx[c(\"b\", \"a\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nb a \n2 1 \n```\n\n\n:::\n\n\n\n</details>\n:::\n\n:::\n\n\n## Scalar--Vector Operations\n\nWhen a scalar and a vector appear together in an operation, the operation is applied to the scalar and to every element in the vector. \n\n### Scalar--Vector Multiplication\n\nTo multiply a scalar by a vector, multiply every element in the vector by the scalar. If *a* is a scalar,\n\n\n$$a\\vec{x}=\\left(ax_1, ax_2,\\ldots, ax_n\\right)$$\n\n\nThey are called \"scalars\" because a scalar multiplied by a vector \"scales\" the vector by changing its magnitude.\n\n$$\\left\\|a\\vec{x}\\right\\|=a\\left\\|\\vec{x}\\right\\|$$\n\nYou can play with scalar multiplication with the web app in @fig-scalar. Set the *x* and *y* coordinates for the blue vector, and alter the scalar *a* to see how the red vector's magnitude changes. When *a* is negative, the red vector reverses direction.\n\n### Scalar--Vector Division\n\nScalar-vector division looks just like it does in regular algebra and can take on a variety of forms:\n\n$$\n\\vec{x}/a=\\frac{\\vec{x}}{a}=\\frac{1}{a}\\vec{x}=a^{-1}\\vec{x}=\\vec{x}\\div a\n$$\n\n### Scalar-Vector Addition\n\nScalar--vector addition works in similar fashion. To add scalar to a vector:\n\n$$\\vec{x}+a=\\left(x_1+a,x_2+a,\\ldots,x_n+a\\right)$$\n\nThat is, the scalar is added to every value of the vector.\n\n### Scalar-Vector Subtraction\n\nTo subtract:\n\n$$\\vec{x}-a=\\left(x_1-a, x_2-a,\\ldots,x_n-a\\right)$$\n\n### Scalar-Vector Operations in R\n\n[In R, almost everything---even things that look like scalars---are really vectors. When a scalar (i.e., a vector of length 1) and a longer vector are added, subtracted, multiplied, or divided, the scalar is \"recycled\" across all the values of longer vector. This is also true when a short vector (e.g., of length 2) is added to a longer vector (e.g., of length 4): the shorter vector is recycled across the longer vector. For example, `c(1,2) + c(1,2,3,4)` will return `2 4 4 6`]{.column-margin}\n\nScalar-vector operations look just alike scalar-scalar operations:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(1,2)\nx + 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6 7\n```\n\n\n:::\n\n```{.r .cell-code}\nx - 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 1\n```\n\n\n:::\n\n```{.r .cell-code}\nx * 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 8\n```\n\n\n:::\n\n```{.r .cell-code}\nx / 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5 1.0\n```\n\n\n:::\n:::\n\n\n\n## Vector--Vector Operations\n\nA vector--vector operation is when one vector operates on another vector.\n\n### Vector Addition and Subtraction\n\nTo add two vectors, add each element at the same position:\n\n$$\n\\begin{aligned}\n\\vec{x}&= \\left(x_1,x_2,\\ldots,x_n\\right)\\\\\n\\vec{y}&= \\left(y_1,y_2,\\ldots,y_n\\right)\\\\\n\\vec{x}+\\vec{y}&= \\left(x_1+y_1,x_2+y_2,\\ldots,x_n+y_n\\right)\\\\\n\\end{aligned}\n$$\n\nAs an example:\n\n$$\n\\begin{aligned}\n\\vec{x}&= \\left(1,2\\right)\\\\\n\\vec{y}&= \\left(3,4\\right)\\\\\n\\\\\n\\vec{x}+\\vec{y}&= \\left(1+3,2+4\\right)\\\\\n&= \\left(4,6\\right)\n\\end{aligned}\n$$\n\nVector subtraction works the same way as vector addition, subtracting each element at the same position:\n\n$$\n\\vec{x}-\\vec{y}= \\left(x_1-y_1,x_2-y_2,\\ldots,x_n-y_n\\right)\n$$\n\nAdding and subtracting two vectors is only defined when the vectors have the same number of elements. Thus, if $\\vec{x}= \\left(1,2\\right)$ and $\\vec{y}= \\left(3,2,1\\right)$, there is no defined way to add $\\vec{x}$ and $\\vec{y}$.\n\n\nIn R, adding and subtracting vectors is beautifully easy. Most operations in R are *vectorized*, meaning that functions automatically operate on all elements of the vector. Unlike many programming languages, R does not require looping structures to add each element pair one at a time. This feature of R simplifies calculations greatly. For addition, we just define the vectors and add them:\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(1, 2)\ny <- c(3, 4)\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 6\n```\n\n\n:::\n:::\n\n\n:::{.column-margin}\nIn many programming languages, adding vectors would require looping. R has looping structures, too. They are useful for complex operations, but they are overkill for simple operations. For example, instead of just typing `x + y`, looping through each element of `x` and `y` would look like this:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\n# Define empty variable to contain the result\nx_plus_y <- numeric(length(x))\n\nfor (i in seq_along(x)) {\n  x_plus_y[i] <- x[i] + y[i]\n}\n\nx_plus_y \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 6\n```\n\n\n:::\n:::\n\n\nTruth be told, if the language requires this kind of extra verbiage, there are usually shortcut functions to avoid the hassle. Thankfully R does not need any shortcuts. The natural way of performing operations is already short enough.  \n\n:::\n\n::: {.callout-note title=\"You Try\"}\n\nIf vector $\\vec{a}$ is (5, 6) and vector $\\vec{b}$ is (10, 1), what is the sum of $\\vec{a}$ and $\\vec{b}$? Use R to compute your answer.\n\n```{webr-r}\n#| label: ex-addvectors\na <- c(5, 6)\nb <- c(10, 1)\n```\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" solutionsetter='true'}\n\n<details><summary>Suggested Solution</summary>\n\n```{.r .cell-code}\na <- c(5, 6)\nb <- c(10, 1)\na + b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15  7\n```\n\n\n:::\n\n\n\n</details>\n:::\n\n\n:::\n\n\n\n\n\n::: {.cell .fig-column-margin .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n::: {.cell-output-display}\n![A vector of (4, 3) moves 4 units to the right and 3 units up from the origin.](vectors_files/figure-html/fig-vector-1.png){#fig-vector fig-align='center' width=100%}\n:::\n:::\n\n\nA vector with two scalar elements can be thought of as an arrow in a coordinate plane, as in @fig-vector. The vector $\\left(4, 3\\right)$ is an arrow that displaces any point it is added to by 4 units to the right and 3 units up. \n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" button_before='true' button_after='true' codelabel='R Code'}\n:::{.callout-note collapse=\"true\" appearance=\"minimal\"}\n## R Code for @fig-vector\n\n```{.r .cell-code}\no <- ob_point(0,0, color = myfills[1])\np <- ob_point(x_plot, y_plot, color = myfills[1])\nv <- ob_segment(o, p, \n             resect_head = 1.5, \n             arrow_head = my_arrowhead, \n             color = myfills[1], \n             size = 18) \nmiddle_axes() +\n  p  + \n  ob_latex(tex = paste0(\"\\\\vec{v}=\", p@auto_label),\n           center = p,\n           vjust = -.1,\n           hjust = .4,\n           color = myfills[1],\n           height = .3,\n           density = 900) +\n  v +\n  ob_latex(tex = paste0(\"\\\\left\\\\|\\\\vec{v}\\\\right\\\\|=\", \n                      round(p@r,2)), \n           center = v@midpoint(), \n           height = .35, \n           color = myfills[1], \n           vjust = -.1, \n           angle = v@line@angle, \n           density = 900)\n```\n\n\n:::\n:::\n\n\n\n::: {.cell .fig-column-margin .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n::: {.cell-output-display}\n![Vector addition](vectors_files/figure-html/fig-vector_addition-1.png){#fig-vector_addition fig-align='center' width=100%}\n:::\n:::\n\n\n\n\nIn @fig-vector-addition, you can play with vector addition.\n\n### Vector Norms\n\nIf we visualize a vector as an arrow, we can ask how long the arrow is from end to end. The [norm]{.defword title=\"A vector's **norm** is the Euclidean distance of the vector's *n* elements to the origin in *n*-dimensional space.\"} is the vector's magnitude. Imagine the vector's *n* elements plotted as a single point in *n*-dimensional space. The norm is the distance of the point to the origin (i.e., a vector of *n* zeroes). The distance referred to here is technically the Euclidean distance, which is a generalization of the Pythagorean Theorem to more than 2 dimensions. To calculate it, take the square root of the sum of all squared values in the vector.\n\n:::{.column-margin}\n\nVector norms sometimes have notation that can be confused with absolute values: \n\n$$\\left|\\vec{x}\\right|$$\n\nThe notational confusion is not accidental. Scalar absolute values and vector norms both refer to magnitude. Indeed, if you apply the formula for vector norms to a vector with one element, the result is  the absolute value:\n\n$$\\sqrt{x_1^2} = |x_1|$$\n\n\nHowever, to avoid the ambiguity between vector norms and taking the absolute value of each element, I will use the double bar notation: \n\n$$\\left\\|\\vec{x}\\right\\|$$\n\nI tend to be fastidious about distinguishing between *vector length* (the number of elements in a vector) and vector *norms* (the vector's magnitude) because the concepts are easily confused. Further confusion is that the norm of a vector is not the same thing as a *normal vector*, which is a vector that is perpendicular to a surface (e.g., a plane, a sphere, or any other multidimensional object) at a given point. A normal vector has nothing to do with the normal distribution.\n\n:::\n\n\n$$\n\\left\\|\\vec{x}\\right\\|=\\sqrt{x_1^2+x_2^2+\\ldots+x_n^2}$$\n\nTo calculate a vector norm in R by hand is straightforward:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(4, 3)\nsqrt(sum(x ^ 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\nIf you can remember that this kind of norm (there are others) is a \"type 2\" norm, then a vector norm can be calculated with the `norm` function:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nnorm(x, type = \"2\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n\n### Unit Vectors\n\nA vector norm is useful for creating [unit vectors]{.defword title=\"A unit vector has a norm of 1\" inmargin=\"false\"}[A *unit vector* $\\vec{u}$ has a norm of 1: $\\left\\|\\vec{u}\\right\\|=1$]{.defword .column-margin}, which have the same direction as the original vector but have a norm (i.e., magnitude) of 1.\n\nSo a unit vector $\\vec{u}$ that has the same direction as vector $\\vec{x} = \\left(3,4\\right)$ is:\n\n$$\n\\begin{align*}\n\\vec{u}&=\\frac{\\vec{x}}{\\left\\|\\vec{x}\\right\\|}\\\\\n&=\\frac{\\left(3,4\\right)}{\\sqrt{3^2+4^2}}\\\\\n&=\\frac{\\left(3,4\\right)}{5}\\\\\n&=\\left(.6,.8\\right)\n\\end{align*}\n$$\n\nWe can verify that $\\vec{u}$ has a norm of 1:\n\n$$\n\\begin{align*}\n\\left\\|\\vec{u}\\right\\|&=\\left\\|\\left(.6,.8\\right)\\right\\|\\\\\n&=\\sqrt{.6^2+.8^2}\\\\\n&=1\n\\end{align*}\n$$\n\n\nUnit vectors have many uses, including the calculation of correlation coefficients.\n\n### Vector Multiplication\n\nThere are several different ways that vectors can be multiplied. For now, the most important are element-wise multiplication and dot-product multiplication.\n\n#### Element-wise Multiplication $(\\circ)$\n\nThis kind of multiplication is analogous to vector addition and subtraction. If two vectors have the same length (i.e., number of elements), element-wise multiplication creates a vector of the same length by multiplying each element. Thus,\n\n$$\n\\begin{aligned}\n\\vec{x}&= \\left(x_1,x_2,\\ldots,x_n\\right)\\\\\n\\vec{y}&= \\left(y_1,y_2,\\ldots,y_n\\right)\\\\\n\\vec{x}\\circ \\vec{y}&= \\left(x_1y_1,x_2 y_2,\\ldots,x_n y_n\\right)\\\\\n\\end{aligned}\n$$\n\nIn R, element-wise multiplication is straightforward. Just multiply the vectors with the `*` operator.\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\ny <- c(2, 4, 6)\nx * y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  8 18\n```\n\n\n:::\n:::\n\n\n\n\n#### Dot-Product Multiplication $(\\cdot)$\n\nThis is the same as element-wise multiplication, but the products are added together to create a scalar. \n\n$$\n\\begin{aligned}\n\\vec{x}&= \\left(x_1,x_2,\\ldots,x_n\\right)\\\\\n\\vec{y}&= \\left(y_1,y_2,\\ldots,y_n\\right)\\\\\n\\vec{x}\\cdot \\vec{y}&= x_1 y_1+x_2 y_2+\\ldots+x_n y_n\\\\\n\\end{aligned}\n$$\n\n\nIf $\\vec{x}=(1,2)$ and $\\vec{y}=(3,4)$,\n\n$$\n\\begin{aligned}\n\\vec{x} \\cdot \\vec{y}&=1\\cdot 3+2\\cdot 4\\\\\n&=3+8\\\\\n&=11\n\\end{aligned}\n$$\n\nAs will be seen later, the dot-product of 2 vectors is performed in R with the same operator as matrix multiplication: `%*%`.\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(1, 2)\ny <- c(3, 4)\nx %*% y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]   11\n```\n\n\n:::\n:::\n\n\nHowever, if this is hard to remember, then the dot product can thought of as \"the sum of the elements multiplied\" like so:\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nsum(x * y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n:::\n\n\nI was surprised to learn that in matrix algebra dot-product multiplication is much more often used than element-wise multiplication. Indeed, matrix multiplication consists of many dot-product multiplications. Apart from that, dot-product multiplication has a number of important applications related to the Law of Cosines, finding orthogonal vectors (i.e., vectors at right angles), and the geometric interpretation of correlation coefficients. I will leave those topics for later.\n",
    "supporting": [
      "vectors_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}