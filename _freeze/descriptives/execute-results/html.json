{
  "hash": "c949b5e8c98ac3b26026872b08806da3",
  "result": {
    "engine": "knitr",
    "markdown": "# Descriptives\n\n\n\n\n\n\n\n\n\n\n\nWhen we encounter large lists of unsorted numbers, we have no natural capacity to perceive the list's fundamental characteristics such as its average or its variability. Therefore, we need [descriptive statistics]{.defword title=\"**Descriptive statistics** summarize noteworthy characteristics of samples.\"} to quantify salient characteristics of distributions, or we need to display the numbers in a plot, making them easier to understand and communicate.\n\n## Frequency Distribution Tables\n\nA simple way to describe a distribution is to list how many times each value in the distribution occurs. For example, in this distribution: $\\{10, 3, 4, 10, 6, 4, 6, 4\\}$, there is 1 three, 3 fours, 2 sixes, and 2 tens. The value that occurs most often is four. A [frequency distribution table]{.defword title=\"A **frequency distribution table** summarises a sample by showing the frequency counts of each member of the sample space.\"} displays the number of times each value occurs, as in @tbl-frequencydistributiontable.\n\n\n\n\n\n::: {#tbl-frequencydistributiontable .cell .column-margin .fig-cap-location-margin .tbl-cap-location-bottom layout-align=\"center\" tbl-cap='Frequency Distribution Table<br>The median is 5, halfway between the two middle scores of 4 and 6.'}\n::: {.cell-output-display}\n\n\n| Value| Frequency| Cumulative<br>Frequency| Proportion| Cumulative<br>Proportion|\n|-----:|---------:|-----------------------:|----------:|------------------------:|\n|     3|         1|                       1|       .125|                     .125|\n|     4|         3|                       4|       .375|                     .500|\n|     6|         2|                       6|       .250|                     .750|\n|    10|         2|                       8|       .250|                        1|\n\n\n:::\n:::\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" button_before='true' button_after='true' codelabel='R Code'}\n:::{.callout-note collapse=\"true\" appearance=\"minimal\"}\n## R Code for @tbl-frequencydistributiontable\n\n```{.r .cell-code}\nX <- c(3,4,6,10)\nreps <- c(1,3,2,2)\nd <- map2(X, reps, rep) %>% unlist %>% \n  tibble(X = .) %>% \n  group_by(X) %>% \n  summarise(f = n()) %>% \n  mutate(cf = cumsum(f),\n         p = (f / sum(f)) , \n         cp = cumsum(p) %>% \n           prob_label(accuracy = .001)) %>% \n  mutate(p = prob_label(p, accuracy = .001))\n\nsixes <- reps[X == 6]\nsample_size = sum(reps)\n\n\nknitr::kable(\n  d,\n  col.names = c(\n    \"Value\",\n    \"Frequency\",\n    \"Cumulative<br>Frequency\" ,\n    \"Proportion\",\n    \"Cumulative<br>Proportion\"\n  ),\n  align = \"rrrrr\",\n  escape = F\n)\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIt is common to include alongside the frequencies of each value the proportion (or percentage) of times a value occurs. If the frequency of sample space element $i$ is $f_i$, and the total sample size is $n$, then the proportion of sample space element $i$ is\n\n$$p_i = \\frac{f_i}{n}$$\n\nIn @tbl-frequencydistributiontable, the frequency of sixes is $f=2$ and there are $n = 8$ numbers in the distribution, thus the proportion of sixes is $p = \\frac{2}{8} = .25$.\n\nIt is also common to supplement frequency distribution tables with additional information such as the [cumulative frequency]{.defword title=\"The **cumulative frequency** tells us the number of scores in a distribution that are equal to or lower than a particular sample space element.\"}. For each sample space element, the cumulative frequency $(cf)$ is the sum of the frequencies $(f)$ of the current and all previous sample space elements.\n\n$$cf_i= \\sum_{j=1}^{i}{f_j}$$\n\nOrdinal, interval, and ratio variables can have cumulative frequencies, but not nominal variables. To calculate cumulative frequencies, the sample space needs to be sorted in a meaningful way, which is not possible with true nominal variables. That is, there are no scores \"below\" any other scores in nominal variables.\n\nThe cumulative proportion $(cp)$ is the proportion of scores less than or equal to a particular sample space element.\n\n$$cp_i = \\frac{cf_i}{n}$$\n\n### Frequency Distribution Tables in R\n\nLet's start with a data set from @garciaWomenReactionsIngroup2010, which can accessed via the psych package. \n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\n# Get the Garcia data set from the psych package\nd <- psych::Garcia\n```\n:::\n\n\n\n\n\nThe sjmisc package [@R-sjmisc] provides a quick and easy way to create a frequency distribution table with the `frq` function.\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nsjmisc::frq(d$anger)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx <numeric> \n# total N=129 valid N=129 mean=2.12 sd=1.66\n\nValue |  N | Raw % | Valid % | Cum. %\n-------------------------------------\n    1 | 73 | 56.59 |   56.59 |  56.59\n    2 | 24 | 18.60 |   18.60 |  75.19\n    3 |  4 |  3.10 |    3.10 |  78.29\n    4 |  8 |  6.20 |    6.20 |  84.50\n    5 | 12 |  9.30 |    9.30 |  93.80\n    6 |  7 |  5.43 |    5.43 |  99.22\n    7 |  1 |  0.78 |    0.78 | 100.00\n <NA> |  0 |  0.00 |    <NA> |   <NA>\n```\n\n\n:::\n:::\n\n\n\n\n\nTypically we use frequency distribution tables to check whether the values of a variable are correct and that the distribution makes sense to us. Thus the `frq` function is all we need most of the time. However, if you need a publication-ready frequency distribution table, you will probably have to make it from scratch (See @tbl-freqtablepub).\n\n\n\n\n\n::: {#tbl-freqtablepub .cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" tbl-cap='Frequency Distribution Table for Anger<br>*f*&nbsp;=&nbsp;Frequency,*cf*&nbsp;=&nbsp;Cumulative Frequency, *p*&nbsp;=&nbsp;Proportion, and *cp*&nbsp;=&nbsp;Cumulative Proportion'}\n::: {.cell-output .cell-output-stdout}\n\n```\n  *X* *f* *cf* *p* *cp*  \n1   1  73   73 .57  .57  \n2   2  24   97 .19  .75  \n3   3   4  101 .03  .78  \n4   4   8  109 .06  .84  \n5   5  12  121 .09  .94  \n6   6   7  128 .05  .99  \n7   7   1  129 .01 1.00  \n```\n\n\n:::\n:::\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" button_before='true' button_after='true' codelabel='R Code'}\n:::{.callout-note collapse=\"true\" appearance=\"minimal\"}\n## R Code for @tbl-freqtablepub\n\n```{.r .cell-code}\n# Publication-quality frequency table\nd %>% \n  rename(X = anger) %>% \n  count(X, name = \"f\") %>% \n  mutate(cf = cumsum(f),\n         p = f / sum(f),\n         cp = cumsum(p)) %>% \n  mutate(across(\n    .cols = p:cp,\n    .fns = function(x) scales::number(x, .01) %>% \n      str_remove(\"^0\"))) %>% \n  rename_with(\n    .fn = function(x) paste0(\"*\",x,\"*\")) %>% \n  mutate(` ` = \"\") \n```\n\n\n:::\n:::\n\n\n\n\n\n### Frequency Distribution Bar Plots\n\n\n\n\n\n::: {.cell .fig-column-margin .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"left\"}\n::: {.cell-output-display}\n![Frequency Distribution Bar Plot](descriptives_files/figure-html/fig-freqbarplot-1.png){#fig-freqbarplot fig-align='left' width=350}\n:::\n:::\n\n::: {.cell .fig-column-margin .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"left\"}\n::: {.cell-output-display}\n![Cumulative Frequency Stacked Bar Plot](descriptives_files/figure-html/fig-freqstackedbarplot-1.png){#fig-freqstackedbarplot fig-align='left' width=250}\n:::\n:::\n\n::: {.cell .fig-column-margin .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"left\"}\n::: {.cell-output-display}\n![Cumulative Frequency Step Plot](descriptives_files/figure-html/fig-freqstepplot-1.png){#fig-freqstepplot fig-align='left' width=350}\n:::\n:::\n\n\n\n\n\nIn @fig-freqbarplot, the frequency distribution from @tbl-freqtablepub is translated into a standard bar plot in which each bar is proportional to the frequency of each response. A column bar plot allows for easy comparison of the frequency of each category. For example, in @fig-freqbarplot, the most frequent response to the Anger question---1 (low)---draws your attention immediately. In contrast to the mental effort needed to scan frequencies listed in a table, the relative height of each frequency in the bar plot is perceived, compared, and interpreted almost effortlessly. With a single glance at @fig-freqbarplot, no calculation is required to know that none of the other responses is even half as frequent as 1.\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" button_before='true' button_after='true' codelabel='R Code'}\n:::{.callout-note collapse=\"true\" appearance=\"minimal\"}\n## R Code for @fig-freqbarplot\n\n```{.r .cell-code}\n# Make frequency data\nd_freq <- d %>% \n  rename(Anger = anger) %>% \n  count(Anger, name = \"f\") %>% \n  mutate(cf = cumsum(f),\n         p = f / sum(f),\n         cp = cumsum(p))\n\n# Frequency Bar Plot\nd_freq %>% \n  ggplot(aes(Anger, f)) + \n  geom_col(fill = myfills[1]) + \n  geom_richlabel(aes(label = f), \n                 vjust = 0, \n                 label.margin = margin(),\n                 text_size = 30) +\n  scale_x_continuous(breaks = 1:7, \n                     minor_breaks = NULL) + \n  scale_y_continuous(\"Frequency\", \n                     expand = expansion(c(0, 0.09))) +\n  theme_minimal(base_size = 30, \n                base_family = bfont) + \n  theme(panel.grid.major.x = element_blank())       \n```\n\n\n:::\n:::\n\n\n\n\n\n### Frequency Distribution Stacked Bar Plots\n\nIn a standard bar plot, one may easily compare frequencies to each other, but that may not be what you wish the reader to notice first. A stacked bar plot emphasizes the proportions of each category as it relates to the whole. It also allows for the visual display of the cumulative frequencies and proportions. For example, in @fig-freqstackedbarplot, it is easy to see that more than half of participants have an anger level of 1, and three quarters have an anger level of 2 or less.\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" button_before='true' button_after='true' codelabel='R Code'}\n:::{.callout-note collapse=\"true\" appearance=\"minimal\"}\n## R Code for @fig-freqstackedbarplot\n\n```{.r .cell-code}\n# Stacked Frequency Bar Plot\n\nd_freq %>% \n  ggplot(aes(factor(\"Anger\"), cf - f / 2)) + \n  geom_tile(aes(height = f, fill = factor(Anger)), \n            width = 1.2) +\n  geom_text(aes(label = paste0(\n    Anger, \n    \" (\", \n    f, \n    \", \",\n    scales::percent(p, accuracy = 1),\n    \")\"))) + \n  scale_y_continuous(\n    \"Cumulative Frequency\",\n    breaks = c(0, d_freq$cf),\n    minor_breaks = NULL,\n    expand = expansion(c(0, .04)),\n    sec.axis = sec_axis(\n      trans = ~ .x,\n      labels = scales::percent(c(0, d_freq$cp), \n                               accuracy = 1),\n      breaks = c(0, d_freq$cf),\n      name = \"Cumulative Percentage\"))  +\n  scale_fill_manual(values = tinter::tinter(myfills[1], 9)) +\n  scale_x_discrete(NULL) +\n  theme(\n    legend.position = \"none\",\n    panel.grid = element_blank(),\n    axis.text.y = element_text(vjust = c(rep(0.5, 7),-0.3))\n  ) \n```\n\n\n:::\n:::\n\n\n\n\n\n### Frequency Distribution Step Line Plots\n\nA step line plot can show the cumulative frequency's relationship with the variable. For example, in  @fig-freqstepplot, it appears that the cumulative frequency rises quickly at first but then rises slowly and steadily thereafter.\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" button_before='true' button_after='true' codelabel='R Code'}\n:::{.callout-note collapse=\"true\" appearance=\"minimal\"}\n## R Code for @fig-freqstepplot\n\n```{.r .cell-code}\n# Frequency Step Plot\nd_freq %>%\n  ggplot(aes(Anger, cf)) +\n  geom_step(direction = \"mid\",\n            color = myfills[1],\n            linewidth = 0.5) +\n  geom_richlabel(\n    aes(label = cf),\n    vjust = 0,\n    color = myfills[1],\n    label.margin = margin(b = 1),\n    text_size = 30\n  ) +\n  geom_richlabel(\n    aes(label = signs::signs(\n      f, accuracy = 1, add_plusses = T\n    )),\n    vjust = 1,\n    color = \"gray40\",\n    text_size = 30\n  ) +\n  scale_x_continuous(breaks = 1:7,\n                     expand = expansion()) +\n  scale_y_continuous(\n    \"Cumulative Frequency\",\n    limits = c(0, NA),\n    breaks = 0,\n    minor_breaks = NULL,\n    expand = expansion(mult = c(0.001, 0.07))\n  ) +\n  theme_minimal(base_size = 30, base_family = bfont) +\n  theme(panel.grid.major.x = element_blank()) +\n  annotate(\n    geom = \"segment\",\n    x = 0.5,\n    y = 0,\n    xend = 0.5,\n    yend = 73,\n    color = myfills[1],\n    linewidth = 1\n  ) +\n  annotate(\n    geom = \"segment\",\n    x = 0.5,\n    y = 73,\n    xend = 1,\n    yend = 73,\n    color = myfills[1],\n    linewidth = 0.5\n  ) +\n  annotate(\n    geom = \"segment\",\n    x = 7,\n    y = 129,\n    xend = 7.5,\n    yend = 129,\n    color = myfills[1],\n    linewidth = 0.5\n  ) \n```\n\n\n:::\n:::\n\n\n\n\n\n## Measures of Central Tendency\n\nIf we need to summarize an entire distribution with a single number with the least possible information loss, we use a measure of central tendency---usually the mode, the median, or the mean. Although these numbers are intended to represent the entire distribution, they often require accompaniment from other statistics to perform this role with sufficient fidelity. \n\nOur choice of which measure of central tendency we use to summarize a distribution depends on which type of variable we are summarizing (i.e., nominal, ordinal, interval, or ratio) and also a consideration of each central tendency measure's strengths and weaknesses in particular situations.\n\n### Mode\n\nThe [mode]{.defword title=\"The **mode** is the value in a distribution that occurs most often.\"} is the most frequent score in a distribution. Suppose we have a distribution that looks like this: \n\n$$\\{1,2,2,2,2,3,3\\}$$\n\nBecause 2 occurs more frequently than the other values in the distribution, the mode is 2. \n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n:::\n\n\n\n\n\nIn a frequency distribution table, the mode is the value with the highest value in the $f$ (frequency) column. In @tbl-freqtablepub, the mode is 1 because it has the highest frequency $(f = 73)$. \n\nIn a bar plot, histogram, or probability density plot, the mode is the value that corresponds to the highest point in the plot. For example, in @fig-freqbarplot, the modal value is 1 because its frequency of 73 is the highest point in the bar plot. In @fig-bimodal, the mode is &minus;1 because that is the highest point in the density plot. \n\nIf two values tie, both values are the mode and the distribution is [bimodal]{.defword title=\"A **bimodal** distribution has two modes.\"}. Sometimes a distribution has two distinct clusters, each with its own local mode. The greater of these two modes is the *major mode*, and the lesser is the *minor mode* (See @fig-bimodal).\n\n\n\n\n\n::: {.cell .fig-column-margin .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"left\"}\n::: {.cell-output-display}\n![A Bimodal Distribution](descriptives_files/figure-html/fig-bimodal-1.png){#fig-bimodal fig-align='left' width=100%}\n:::\n:::\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" button_before='true' button_after='true' codelabel='R Code'}\n:::{.callout-note collapse=\"true\" appearance=\"minimal\"}\n## R Code for @fig-bimodal\n\n```{.r .cell-code}\n# A bimodal distribution\ntibble(x = seq(-3, 3.5, .01),\n       y = dnorm(x,-1, 0.5) / 0.8 + \n         dnorm(x, 1, 0.75)) %>%\n  ggplot(aes(x, y)) +\n  geom_area(fill = myfills[1], alpha = .5) +\n  geom_text(\n    data = . %>% dplyr::filter(x == -1),\n    vjust = -0.25,\n    label = \"Major\\nMode\",\n    size = 8,\n    lineheight = 0.9,\n    color = \"gray30\"\n  ) +\n  geom_text(\n    data = . %>% dplyr::filter(x == 1),\n    vjust = -0.25,\n    label = \"Minor\\nMode\",\n    size = 8,\n    lineheight = 0.9,\n    color = \"gray30\"\n  ) +\n  scale_x_continuous(NULL,\n                     minor_breaks = NULL,\n                     breaks = seq(-3, 3)) +\n  scale_y_continuous(NULL,\n                     breaks = NULL,\n                     expand = expansion(c(0, .25))) +\n  theme_minimal(base_size = 30,\n                base_family = bfont) +\n  theme(panel.grid.major.x = element_blank()) \n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe mode is the only measure of central tendency that be computed for all variable types and is the only choice for nominal variables (See @tbl-proconCT).\n\nTo compute the mode of a variable, use the `mfv` (most frequent value) function from the modeest package [@R-modeest]. In this example, the 2 occurs four times.\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\n# Data\nx <- c(1,2,2,2,2,3,3)\n# Mode\nmodeest::mfv(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\nThe `mfv` function will return all modes if there is more than one. In this example, the 1, 3, and 4 all occur twice.\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\n# Data\nx <- c(1,1,3,3,4,4,5,6)\n# Mode\nmodeest::mfv(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3 4\n```\n\n\n:::\n:::\n\n\n\n\n\n### Median\n\nThe [median]{.defword title=\"The **median** is the point that divides the lower 50 percent of a distribution from the upper 50 percent.\"} is midpoint of a distribution, the point that divides the lower half of the distribution from the upper half. To calculate the median, you first need to sort the scores. If there is an odd number of scores, the median is the middle score. If there an even number of scores, it is the mean of the two middle scores. There are other definitions of the median that are a little more complex, but rarely is precision needed for calculating the median.\n\nTo find the median using a frequency distribution table, find the first sample space element with a cumulative proportion greater than 0.5. For example, in the distribution shown in @tbl-mediantable, the first cumulative proportion greater than 0.5 occurs at 5, which is therefore the median.\n\n\n\n\n\n::: {#tbl-mediantable .cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" tbl-cap='Finding the Median in a Frequency Distribution Table.<br>In this case, the median is 5 because it has the first cumulative proportion that is greater than 0.5.'}\n::: {.cell-output-display}\n\n\n| *X* | Frequency | Cumulative Frequency | Proportion | Cumulative Proportion |\n|:---:|:---------:|:--------------------:|:----------:|:---------------------:|\n|  1  |     1     |          1           |    .14     |          .14          |\n|  5  |     3     |          4           |    .43     |          .57          |\n|  7  |     1     |          5           |    .14     |          .71          |\n|  9  |     2     |          7           |    .29     |           1           |\n\n\n:::\n:::\n\n\n\n\n\nIf a sample space element's cumulative proportion is exactly 0.5, average that sample space element with the next highest value. For example, in the distribution in @tbl-frequencydistributiontable, the cumulative proportion for 4 is exactly 0.5 and the next value is 6. Thus the median is \n\n$$\\frac{4+6}{2}=5$$\n\nThe median can be computed for ordinal, interval, and ratio variables, but not for nominal variables (See @tbl-proconCT). Because nominal variables have no order, no value is \"between\" any other value. Thus, because the median is the middle score and nominal variables have no middle, nominal variables cannot have a median.\n\nFor ordinal variables, the median is the preferred measure of central tendency because it is usually more stable from one sample to the next compared to the mode.\n\nIn R, the `median` function can compute the median:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nmedian(c(1,2,3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\n### Mean\n\nThe [arithmetic mean]{.defword title=\"The **arithmetic mean** is the balance point of a disribution.\"} is the sum of all values of a distribution divided by the size of the distribution.\n\n$$\\mu_X = \\frac{\\sum_{i = 1}^n {X_i}}{n}$$\n\nWhere \\begin{align*}\n  \\mu_X &= \\text{The population mean of } X\\\\\n  n &= \\text{The number of values in } X\n\\end{align*}\n\nThe arithmetic mean can only be calculated with interval or ratio variables. Why? The formula for the mean requires adding numbers, and the operation of addition is not defined for ordinal and nominal values.\n\nThe arithmetic mean is usually the preferred measure of central tendency for interval and ration variables because it is usually more stable from sample to sample than the median and the mode. In @fig-centraltendency, it can be seen that the sampling distributions of the mean is narrower than that of the median and the mode. In other words, it has a smaller [standard error]{.defword title=\"The **standard error** is the standard deviation of a sampling distribution.\"}.\n\n\n\n\n\n::: {.cell .fig-column-margin .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"left\"}\n::: {.cell-output-display}\n![Sampling Distributions of Central Tendency Measures.<br>The standard normal distribution, $\\mathcal{N}(0,1),$ was used to generate 10,000 samples with a sample size of 100. The distribution of sample means is slightly narrower than the distribution of sample medians, meaning that the mean is slightly more stable than the median. The distribution of sample modes is very wide, meaning that the mode is much less stable than the mean and median.](descriptives_files/figure-html/fig-centraltendency-1.png){#fig-centraltendency fig-align='left' width=100%}\n:::\n:::\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" button_before='true' button_after='true' codelabel='R Code'}\n:::{.callout-note collapse=\"true\" appearance=\"minimal\"}\n## R Code for @fig-centraltendency\n\n```{.r .cell-code}\n# Central tendency function\nct <- function(sample_size = 100) {\n  x <- rnorm(sample_size)\n  mo <- DescTools::Mode(round(x,2))\n  \n  c(Mean = mean(x), \n       Median = median(x), \n       Mode = sample(mo, 1))\n}\n\n# Replicate samples\nd_ct <- replicate(10000, ct(100)) %>% \n  t() %>% \n  as_tibble() %>% \n  pivot_longer(cols = everything(), \n               names_to = \"CentralTendency\",\n               values_to = \"Value\") %>% \n  mutate(y = recode(CentralTendency, \n                    `Mode` = 0.03, \n                    `Median` = 0.07, \n                    `Mean` = 0.135))\n\n# Summary data\nd_sum <- d_ct %>% \n  filter(!is.na(Value)) %>% \n  group_by(CentralTendency) %>% \n  summarise(x = mean(Value),\n            y = mean(y),\n            ub = quantile(Value, 0.975),\n            lb = quantile(Value, 0.025)) %>% \n  rename(Value = x)\n\n# Plot\nd_ct %>% \n  filter(!is.na(Value)) %>% \n  ggplot(aes(Value, y)) +\n  stat_function(geom = \"area\", \n                fun = function(x) dnorm(x, 0, 1), \n                n = 1000, \n                color = NA, \n                fill = \"gray50\", \n                alpha = 0.2)  +\n  ggdist::stat_halfeye(aes(fill = CentralTendency), \n                       scale = 1.2, \n                       color = \"gray20\") +\n  geom_text(data = d_sum,\n            aes(label = CentralTendency),\n            vjust = 1.5,\n            size = ggtext_size(22),\n            color = \"gray20\") +\n  scale_x_continuous(name = NULL, \n                     limits = c(-3.5,3.5), \n                     breaks = seq(-4,4),\n                     labels = \\(x) signs::signs(x, accuracy = 1)) +\n  theme_minimal(base_size = 22, \n                base_family = bfont) +\n  theme(legend.position = \"none\", \n        panel.grid = element_blank()) +\n  scale_y_continuous(NULL, breaks = NULL, \n                     expand = expansion()) + \n  scale_fill_manual(values = scales::muted(\n    rep(myfills[1], 3),\n    l = c(65, 55, 40)))\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIn R, the `mean` function can compute the median:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nmean(c(1,2,3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\nWatch out for missing values in R. If the distribution has even a single missning value, the `mean` function will return `NA`, as will most other summary functions in R (e.g., `median`, `sd`, `var`, and `cor`).\n\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nmean(c(1,NA,3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n\n\nTo calculate the mean of all non-missing values, specify that all missing values shoule be removed prior to calculation like so:\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nmean(c(1,NA,3), na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\n### Comparing Central Tendency Measures\n\nWhich measure of central tendency is best depends on what kind of variable is needed and also what purpuse it serves. @tbl-proconCT has a list of comparative features of each of the three major central tendency measures.\n\n\n\n\n\n::: {#tbl-proconCT .cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" tbl-cap='Comparing Central Tendency Measures'}\n::: {.cell-output-display}\n\n\n|Feature                           |  Mode  | Median  |   Mean   |\n|:---------------------------------|:------:|:-------:|:--------:|\n|Computable for Nominal Variables  |  Yes   |   No    |    No    |\n|Computable for Ordinal Variables  |  Yes   |   Yes   |    No    |\n|Computable for Interval Variables |  Yes   |   Yes   |   Yes    |\n|Computable for Ratio Variables    |  Yes   |   Yes   |   Yes    |\n|Algebraic Formula                 |   No   |   No    |   Yes    |\n|Unique Value                      |   No   |   Yes   |   Yes    |\n|Sensitive to Outliers/Skewness    |   No   |   No    |   Yes    |\n|Standard Error                    | Larger | Smaller | Smallest |\n\n\n:::\n:::\n\n\n\n\n\n\n\n## Expected Values\n\n(Unfinished)\n\nAt one level, the concept of the [expected value]{.defword title=\"The **expected value** of a random variable is the population mean of the values that the random variable generates.\"} of a random variable is really simple; it is just the population mean of the variable. So why don't we just talk about population means and be done with this \"expected value\" business? It just complicates things! True. In this case, however, there is value in letting some simple things appear to become complicated for a while so that later we can show that some apparently complicated things are actually simple.\n\nWhy can't we just say that the expected value of a random variable is the population mean? You are familiar, of course, with the formula for a mean. You just add up the numbers and divide by the number of numbers $n$:\n\n$$\nm_X=\\frac{\\sum_{i=1}^{n} {x_i}}{n}\n$$\n\nFine. Easy. Except...hmm...random variables generate an infinite number of numbers. Dividing by infinity is tricky. We'll have to approach this from a different angle...\n\nThe expected value of a random variable is a weighted mean. A mean of what? Everything in the sample space. How are the sample space elements weighted? Each element in the sample space is multiplied by its probability of occurring.\n\n\n\n\n\n::: {.cell .fig-column-margin .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"left\"}\n::: {.cell-output-display}\n![Probability Distribution of a Hypothetical Random Variable](descriptives_files/figure-html/fig-pmfX-1.png){#fig-pmfX fig-align='left' width=350}\n:::\n:::\n\n\n\n\n\n\nSuppose that the sample space of a random variable *X* is {2, 4, 8} with respective probabilities of {0.3, 0.2, 0.5}, as shown in @fig-pmfX. \n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" button_before='true' button_after='true' codelabel='R Code'}\n:::{.callout-note collapse=\"true\" appearance=\"minimal\"}\n## R Code for @fig-pmfX\n\n```{.r .cell-code}\ntibble(x = factor(c(2,4,8), levels = 1:8),\n       p = c(0.3, 0.2, 0.5)) %>% \n  ggplot(aes(x,p)) + \n  geom_col(fill = myfills[1]) + \n  geom_text(aes(label = prob_label(p)), \n            vjust = -0.4, \n            family = bfont, \n            size = ggtext_size(18)) + \n  theme_minimal(base_family = bfont, \n                base_size = 18) + \n  scale_y_continuous(\"Probability\", \n                     expand = expansion(mult = c(.01, .10)),\n                     breaks = seq(0,1,.1),\n                     labels = prob_label\n                     ) + \n  scale_x_discrete(\"Sample Space\", drop = F ) + \n  theme(panel.grid.major.x = element_blank())\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe notation for taking the expected value of a random variable $X$ is $\\mathcal{E}(X)$. Can we find the mean of this variable $X$ even if we do not have any samples it generates? Yes. To calculate the expected value of $X$, multiply each sample space element by its associated probability and then take the sum of all resulting products. Thus,\n\n$$\n\\begin{align*}\n\\mathcal{E}(X)&=\\sum_{i=1}^{3}{p_i x_i}\\\\\n&= p_1x_1+p_2x_2+p_3x_3\\\\\n&= (.3\\times 2)+(.2\\times 4)+(.5\\times 8)\\\\\n&=5.4\n\\end{align*}\n$$\n\nThe term *expected value* might be a little confusing. In this case, 5.4 is the expected value of $X$ but $X$ never once generates a value of 5.4. So the expected value is not \"expected\" in the sense that we expect to see it often. It is expected to be close to the mean of any randomly selected sample of the variable that is sufficiently large:\n\n\n\n\n\n::: {.cell .fig-column-margin .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"left\"}\n::: {.cell-output-display}\n![Slicing the Standard Normal Distribution into Ever Thinner Bins](descriptives_files/figure-html/fig-thinbins-1.png){#fig-thinbins fig-align='left' width=100%}\n:::\n:::\n\n\n\n\n\n\n$$\n\\mathcal{E}(X)=\\lim_{n \\to \\infty} \\frac{1}{n}\\sum_{i=1}^{n} {x_i}\n$$\n\nIf a random variable $X$ is discrete, its expected value $\\mathcal{E}(X)$ is the sum of each member of the sample space $x_i$ multiplied by its probability of occurring $p_i$. The probability of occurring is the output of $X$'s probability density function at that location: $p_i=f_X(x_i)$. Thus,\n\n$$\n\\mathcal{E}(X)=\\sum_{i=-\\infty}^{\\infty}{x_i f_X(x_i)}\n$$\n\nWith continuous variables, the number of elements in a sample is infinite. Fortunately, calculus was designed to deal with this kind of infinity. The trick is to imagine that the continuous variable is sliced into bins and that the bins are sliced ever more thinly. If a continuous random variable has probability density function $f_X(x)$, the expected value is\n\n$$\n\\mathcal{E}(X)=\\int_{-\\infty}^{\\infty} {x f_X(x)\\,\\mathrm{d}x}\n$$\n\n\nIf we multiply each value of $X$ by the height of its bin ($p$), we get the mean of the binned distribution. If the bins become ever thinner, as in @fig-thinbins, the product of $X$ and $p$ approximates the expected value of the smooth continuous distribution.\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" button_before='true' button_after='true' codelabel='R Code'}\n:::{.callout-note collapse=\"true\" appearance=\"minimal\"}\n## R Code for @fig-thinbins\n\n```{.r .cell-code}\n# Slicing the standard normal distribution into ever thinner bins\nmake_bins <- function(binPower,\n                      binWidth,\n                      LowerBound,\n                      UpperBound) {\n  tibble(x = seq(LowerBound, UpperBound, binWidth), binPower, binWidth)\n}\n\npmap_df(tibble(\n  binPower = 0:4,\n  binWidth = 2 ^ (-1 * binPower),\n  LowerBound = -4,\n  UpperBound = 4\n),\nmake_bins) %>%\n  mutate(\n    p = pnorm(x + binWidth / 2) - pnorm(x - binWidth / 2),\n    width_label = factor(\n      2 ^ binPower,\n      levels = 2 ^ (0:4),\n      labels = c(\"Width = 1\",\n                 paste0(\"Width = 1/\",\n                        2 ^ (1:4)))\n    )\n  ) %>%\n  ggplot(aes(x, p)) +\n  geom_col(\n    aes(width = binWidth),\n    fill = myfills[1],\n    color = \"white\",\n    lwd = 0.1\n  ) +\n  facet_grid(width_label ~ .,\n             scales = \"free\") +\n  theme_light(base_size = 24,\n              base_family = bfont) +\n  scale_x_continuous(\n    NULL,\n    breaks = -4:4,\n    labels = function(x)\n      signs::signs(x, accuracy = 1),\n    expand = c(0.01, 0)\n  ) +\n  scale_y_continuous(NULL,\n                     breaks = NULL) +\n  theme(\n    panel.grid = element_blank(),\n    # strip.text.y = element_blank(),\n    strip.placement = \"outside\",\n    strip.text.y = element_text(angle = 0),\n    axis.text.x = element_text(hjust = c(rep(.75, 4), rep(0.5, 5)))\n  )\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Measures of Variability\n\n### Variability of Nominal Variables\n\nFor most purposes, the visual inspection of a frequency distribution table or bar plot is all that is needed to understand a nominal variable's variability. I have never needed a statistic that measures the variability of a nominal variable, but if you need one, there are [many from which to choose](https://en.wikipedia.org/wiki/Qualitative_variation). For example, @wilcoxIndicesQualitativeVariation1973 presented this analog to variance for nominal variables:\n\n$$\n\\text{VA} = 1-\\frac{1}{n^2}\\frac{k}{k-1}\\sum_{i=1}^k\\left(f_i-\\frac{n}{k}\\right)^2\n$$\n\nThe qualvar package [@R-qualvar] can compute the primary indices of qualitative variation presented by Wilcox.\n\n\n\n\n\n::: {.cell .fig-column-margin .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"left\"}\n::: {.cell-output-display}\n![The Variance Analog (VA) index of qualitative variation ranges from 0 to 1. It equals 0 when every data point is assigned to the same category and 1 when each category has the same frequency.](descriptives_files/figure-html/fig-nominalvar-1.png){#fig-nominalvar fig-align='left' width=400}\n:::\n:::\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(qualvar)\n\n# Frequencies\nfrequencies =  c(A = 60, B = 10, C = 25, D = 5)\n\n# VA\nVA(frequencies)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.7533333\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIn all of these indices of qualitative variation, the lowest value is 0 when every data point belongs to the same category (See @fig-nominalvar, left panel). Also, the maximum value is 1 when the data points are equally distributed across categories (See @fig-nominalvar, right panel).\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" button_before='true' button_after='true' codelabel='R Code'}\n:::{.callout-note collapse=\"true\" appearance=\"minimal\"}\n## R Code for @fig-nominalvar\n\n```{.r .cell-code}\n# The Variance Analog (VA) index of qualitative variation\nlow_var <- c(A = 100, B = 0, C = 0, D = 0)\nmid_var =  c(A = 60, B = 10, C = 25, D = 5)\nhigh_var = c(A = 25, B = 25, C = 25, D = 25)\n\n\ntibble(\n  Variability = c(\"Low\", \"Middle\", \"High\"),\n  Frequency = list(low_var, mid_var, high_var),\n  VA = map_dbl(Frequency, VA)\n) %>%\n  mutate(\n    Frequency = map(Frequency, function(d)\n      as.data.frame(d) %>%\n        tibble::rownames_to_column(\"Category\")),\n    Variability = paste0(Variability,\n                         \"\\nVA = \",\n                         prob_label(VA)) %>%\n      fct_inorder()\n  ) %>%\n  unnest(Frequency) %>%\n  rename(Frequencies = d) %>%\n  ggplot(aes(Category, Frequencies)) +\n  geom_col(aes(fill = Variability)) +\n  geom_richlabel(\n    aes(label = Frequencies),\n    vjust = 0,\n    label.margin = margin(),\n    label.padding = margin(b = .5, t = .5, l = .5, r = .5),\n    color = \"gray30\",\n    text_size = 30\n  ) +\n  scale_y_continuous(\n    expand = expansion(mult = c(0, 0.08)),\n    breaks = seq(0, 100, 20),\n    minor_breaks = seq(0, 100, 10)\n  ) +\n  scale_fill_manual(values = myfills) +\n  facet_grid(cols = vars(Variability)) +\n  theme_light(base_family = bfont, base_size = 30) +\n  theme(panel.grid.major.x = element_blank(),\n        legend.position = \"none\")\n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Interquartile Range\n\nAs with nominal variables, a bar plot or frequency distribution table can tell you most of what you want to know about the variability of an ordinal variable. If you need a quantitative measure of how much an ordinal variable varies, you have many options. The most important of these is the [interquartile range]{.defword title=\"The **interquartile range** (IQR) is the distance from the score at the 25th percentile to the score at the 75th percentile.\"}.\n\n\n\n\n\n::: {.cell .fig-column-margin .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"left\"}\n::: {.cell-output-display}\n![In a normal distribution with a mean of 100 and a standard deviation of 15, the interquartile range is about 20.2, the distance between 89.9 and 110.1.](descriptives_files/figure-html/fig-normalIQR-1.png){#fig-normalIQR fig-align='left' width=100%}\n:::\n:::\n\n\n\n\n\n\n\nWhen median is a good choice for our central tendency measure, the interquartile range is usually a good choice for our variability measure. Whereas the median is the category that contains the 50th percentile in a distribution, the interquartile range is the distance between the categories that contain the 25th and 75th percentile. That is, it is the range of the 50 percent of data in the middle of the distribution. For example, in @fig-normalIQR, the shaded region is the space between the 25th and 75th percentiles in a normal distribution. The IQR is the width of the shaded region, about 20.2.\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" button_before='true' button_after='true' codelabel='R Code'}\n:::{.callout-note collapse=\"true\" appearance=\"minimal\"}\n## R Code for @fig-normalIQR\n\n```{.r .cell-code}\nIQR_bounds <- qnorm(c(.25, .75), mean = 100, sd = 15)\nl_height = .05\nggplot(data = tibble(x = c(40, 160), y = pnorm(x, 100, 15)), aes(x)) +\n  stat_function(fun = \\(x) dnorm(x, 100, 15),\n                geom = \"area\",\n                alpha = 0.1) +\n  stat_function(\n    fun = \\(x) dnorm(x, 100, 15),\n    geom = \"area\",\n    xlim = qnorm(c(.25, .75), mean = 100, sd = 15),\n    fill = myfills[1],\n    alpha = 0.5\n  ) +\n  scale_y_continuous(NULL, breaks = NULL, expand = expansion()) +\n  scale_x_continuous(NULL, breaks = seq(40, 160, 15)) +\n  theme_minimal(base_size = 28, base_family = bfont) +\n  theme(\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    axis.ticks.x = element_line(color = \"gray30\"), plot.margin = margin()\n  ) +\n  annotate(\n    x = IQR_bounds,\n    y = 0,\n    size = ggtext_size(28),\n    geom = \"richtext\", label.color = NA, fill = NA,\n    label = paste0(\"**\", round(IQR_bounds, 1),\"**<br><span style='font-size:22pt'>\", c(25, 75), \"<sup>th</sup><br>percentile\"),\n    hjust = c(1, 0),\n    lineheight = .9,\n    vjust = 0\n  ) + \n  geom_arrow_segment(\n    data = tibble(\n      x = IQR_bounds[1], \n      y = 0, \n      xend = IQR_bounds[2], \n      yend = 0),\n    aes(x = x, y = y, xend = xend, yend = yend),\n    arrow_head = arrow_head_deltoid(),\n    arrow_fins = arrow_head_deltoid()\n    ) +\n  annotate(x = 100, \n           y = 0,\n           size = ggtext_size(28),\n           label = paste0(\"*IQR*<br>=\", round(IQR_bounds[2] - IQR_bounds[1], 1)),\n           geom = \"richtext\", fill = NA, label.color = NA,\n           vjust = 0) + \n  coord_cartesian(clip = \"off\")\n```\n\n\n:::\n:::\n\n\n\n\n\nIn ordinal data, there is no distance between categories, thus we cannot report the interquartile range *per se*. However, we can report the categories that contain the 25th and 75th percentiles. In @fig-ordinalIQR, the interquartile range has its lower bound at *Disagree* and its upper bound at *Slightly Agree*.\"\n\n\n\n\n\n::: {.cell .fig-column-margin .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"left\"}\n::: {.cell-output-display}\n![In this ordinal variable, the interquartile range has a lower bound at *Disagree* (which contains the 25th percentile) and an upper bound at *Slightly Agree* (which contains the 75th percentile).](descriptives_files/figure-html/fig-ordinalIQR-1.png){#fig-ordinalIQR fig-align='left' width=300}\n:::\n:::\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" button_before='true' button_after='true' codelabel='R Code'}\n:::{.callout-note collapse=\"true\" appearance=\"minimal\"}\n## R Code for @fig-ordinalIQR\n\n```{.r .cell-code}\nd <- tibble(\n  Agreement = c(\n    \"Strongly Disagree\",\n    \"Disagree\",\n    \"Slightly Disagree\",\n    \"Slightly Agree\",\n    \"Agree\",\n    \"Strongly Agree\"\n  ),\n  n = c(23, 85, 93, 121, 20, 26),\n  p = n / sum(n),\n  cp = cumsum(p),\n  ymin = lag(cp, default = 0),\n  ytext = ymin + p / 2\n)\n\nd %>%\n  mutate(Agreement = fct_inorder(Agreement) %>% fct_rev()) %>%\n  ggplot(aes(p, cp)) +\n  geom_rect(aes(\n    ymin = ymin,\n    ymax = cp,\n    xmin = 0,\n    xmax = 1,\n    fill = Agreement\n  )) +\n  geom_label(\n    aes(x = 1, label = paste0(round(cp * 100), \"%\")),\n    hjust = 0,\n    label.size = 0,\n    color = \"gray30\"\n  ) +\n  geom_text(\n    aes(\n      x = 0.5,\n      y = ytext,\n      label = paste0(Agreement,\n                     \" (\",\n                     round(100 * p), \"%)\")\n    ),\n    size = WJSmisc::ggtext_size(18),\n    color = \"gray10\"\n  ) +\n  scale_y_continuous(\n    \"Cumulative Proportion\",\n    minor_breaks = NULL,\n    labels = \\(x) paste0(round(x * 100), \"%\"),\n    expand = expansion(),\n    limits = c(0, 1)\n  ) +\n  scale_x_continuous(\"Agreement\", breaks = NULL, expand = expansion(add = c(0, .2))) +\n  scale_fill_manual(values = rev(c(\n    rev(tinter(myfills[1], steps = 4)[1:3]),\n    tinter(myfills[2], steps = 4)[1:3]\n  ))) +\n  theme(\n    legend.position = \"none\",\n    axis.ticks.y = element_line(\"gray30\"),\n    panel.grid.major.y = element_blank()\n  ) +\n  coord_cartesian(clip = \"off\")\n```\n\n\n:::\n:::\n\n\n\n\n\nThe median and the interquartile range are displayed in box and whiskers plots like @fig-IQRboxplot. The height of the box is the interquartile range, and the horizontal line is the median. The top \"whisker\" extends no higher than 1.5 × *IQR* above the 75th percentile. The bottom \"whisker\" extends no lower than 1.5 × *IQR* below the 25th percentile. Any data points outside the whiskers can be considered outliers.\n\n\n\n\n\n::: {.cell .fig-cap-location-top .tbl-cap-location-margin layout-align=\"center\"}\n::: {.cell-output-display}\n![A Tukey-style Box and Whiskers Plot with Medians and Interquartile Ranges.](descriptives_files/figure-html/fig-IQRboxplot-1.png){#fig-IQRboxplot fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" button_before='true' button_after='true' codelabel='R Code'}\n:::{.callout-note collapse=\"true\" appearance=\"minimal\"}\n## R Code for @fig-IQRboxplot\n\n```{.r .cell-code}\nset.seed(2)\nd <-\n  tibble(\n    A = rnorm(100, 50, 10),\n    C = 1.5 * rchisq(100, 4) + 50,\n    B = rbeta(100, 4.5, .5) * 80\n  ) %>%\n  pivot_longer(cols = everything(),\n               names_to = \"grp\",\n               values_to = \"x\") %>%\n  mutate(grp = factor(grp)) %>%\n  group_by(grp) %>%\n  mutate(\n    md = median(x),\n    IQR = IQR(x),\n    q25 = quantile(x, .25),\n    q75 = quantile(x, .75)\n  ) %>%\n  ungroup() %>%\n  mutate(outlier = ifelse(x > md,\n                          x - q75 > IQR * 1.5,\n                          q25 - x >  IQR * 1.5))\n\nd_stats <- d %>%\n  group_by(grp) %>%\n  summarise(md = median(x),\n            q25 = quantile(x, .25),\n            q75 = quantile(x, 0.75)) %>%\n  pivot_longer(cols = -grp,\n               names_to = \"stats\",\n               values_to = \"x\") %>%\n  mutate(\n    st = case_when(\n      stats == \"md\" ~ \" (Median)\",\n      stats == \"q25\" ~ \" (1<sup>st</sup> Quartile)\",\n      stats == \"q75\" ~ \" (3<sup>rd</sup> Quartile)\"\n    )\n  )\n\nwidth = .3\n\nd %>%\n  ggplot(aes(grp, x)) +\n  geom_boxplot(aes(fill = grp), \n               outlier.color = NA, \n               width = width * 2) +\n  geom_richtext(\n    data = d_stats,\n    aes(label = paste0(\n      scales::number(x, .1), \n      ifelse(grp == \"A\", st, \"\")\n    )),\n    nudge_x = width + .01,\n    label.color = NA,\n    hjust = 0,\n    color = \"gray20\"\n  ) +\n  geom_arrow_segment(\n    data = select(d, grp, q25, q75) %>% \n      unique(),\n    aes(\n      yend = q75,\n      y = q25,\n      x = as.numeric(grp) - width - 0.05,\n      xend = as.numeric(grp) - width - 0.05\n    ),\n    arrow_head = arrow_head_deltoid(),\n    arrow_fins = arrow_head_deltoid(),\n  ) +\n  geom_richtext(\n    data = select(d, grp, q25, q75, IQR) %>% \n      unique(),\n    aes(\n      x = as.numeric(grp) - width - 0.05,\n      y = (q25 + q75) / 2,\n      label = paste0(ifelse(grp == \"A\", \"*IQR* = \", \"\"), scales::number(IQR, .1))\n    ),\n    angle = 90,\n    vjust = -0.2,\n    label.color = NA,\n    label.padding = margin(t = 3)\n  ) +\n  ggbeeswarm::geom_quasirandom(pch = 16,\n                               size = 1,\n                               aes(color = outlier),\n                               width = .3) +\n  scale_x_discrete(\"Group\") +\n  scale_y_continuous(NULL) +\n  scale_fill_manual(values = myfills %>% \n                      scales::alpha(.5)) +\n  scale_color_manual(values = c(\"gray20\", \"firebrick\")) +\n  theme(legend.position = \"none\") \n```\n\n\n:::\n:::\n\n\n\n\n\n### Variance \n\nA [deviation]{.defword title=\"A **deviation** is the distance of a score from the score's mean.\"} is computed by subtracting a score from its mean:\n\n$$X-\\mu$$\n\nWe would like to know the typical size of the deviation $X-\\mu$. To do so, it might seem intuitively correct to take the average (i.e., expected value) of the deviation, but this quantity is always 0:\n\n$$\n\\begin{aligned}\n\\mathcal{E}(X-\\mu)&=\\mathcal{E}(X)-\\mathcal{E}(\\mu)\\\\\n&=\\mu-\\mu\\\\\n&=0\n\\end{aligned}\n$$\n\nBecause the average deviation is always 0, it has no utility as a measure of variability. It would be reasonable to take the average absolute value of the deviations, but absolute values often cause algebraic difficulties later when we want to use them to derive other statistics. A more mathematically tractable solution is to make each deviation positive by squaring them.\n\n[Variance]{.defword title=\"**Variance** is a measure of variability that gives the size of the average squared deviation from the mean.\"} $\\left(\\sigma^2\\right)$ is the expected value of squared deviations from the mean $\\left(\\mu\\right)$:\n\n$$\n\\begin{aligned}\n\\sigma^2&=\\mathcal{E}\\!\\left(\\left(X-\\mu\\right)^2\\right)\\\\\n&=\\mathcal{E}\\!\\left(X^2-2X\\mu+\\mu^2\\right)\\\\\n&=\\mathcal{E}\\!\\left(X^2\\right)-\\mathcal{E}\\!\\left(2X\\mu\\right)+\\mathcal{E}\\!\\left(\\mu^2\\right)\\\\\n&=\\mathcal{E}\\!\\left(X^2\\right)-2\\mu\\,\\mathcal{E}\\!\\left(X\\right)+\\mu^2\\\\\n&=\\mathcal{E}\\!\\left(X^2\\right)-2\\mu\\mu+\\mu^2\\\\\n&=\\mathcal{E}\\!\\left(X^2\\right)-2\\mu^2+\\mu^2\\\\\n&=\\mathcal{E}\\!\\left(X^2\\right)-\\mu^2\\\\\n\\end{aligned}\n$$\n\nIf all elements of a population with mean $\\mu$ are known, the population variance is calculated like so:\n\n$$\n\\sigma^2=\\frac{\\sum_i^n{\\left(x_i-\\mu\\right)^2}}{n}\n$$\n\nNotice that the population variance's calculation requires knowing the precise value of the population mean. Most of the time, we need to estimate the population mean $\\mu$ using a sample mean $m$. A sample variance $\\left(s^2\\right)$  for a sample size $n$ can be calculated like so:\n\n$$\ns^2=\\frac{\\sum_i^n{\\left(x_i-m\\right)^2}}{n-1}\n$$\n\n\n\n\n\n::: {.cell .fig-column-margin .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"left\"}\n::: {.cell-output-display}\n![Friedrich Wilhelm Bessel (1784--1846)<br>[Image Credits](https://en.wikipedia.org/wiki/File:Friedrich_Wilhelm_Bessel_(1839_painting).jpg)](images/Friedrich_Wilhelm_Bessel_(1839_painting).jpg){#fig-besselpic fig-align='left' width=250}\n:::\n:::\n\n\n\n\n\nUnlike with the population variance, we do not divide by the sample size $n$ to calculate the sample variance. If we divided by $n$, the sample variance would be negatively biased (i.e., it is likely to underestimate the population variance). In what is known as Bessel's correction (i.e, dividing by $n-1$ instead of by $n$), we get an unbiased estimate of the variance. \n\nVariance is rarely used for descriptive purposes because it is a squared quantity with no direct connection to the width of the distribution it describes. We mainly use variance as a stepping stone to compute other descriptive statistics (e.g., standard deviations and correlation coefficients) and as an essential ingredient in inferential statistics (e.g., analysis of variance, multiple regression, and structural equation modeling). However, @fig-variancevisualization attempts a visualization of what variance represents. Along the $X$-axis, the values of a normally distributed variable $X$ are plotted as points. The $Y$-axis represents the deviations of variable $X$ from $\\mu$, the mean of $X$. For each value of $X$, we can create a square with sides as long as the deviations from $\\mu$. The red squares have a positive deviation and the blue squares have a negative deviation. The darkness of the color represents the magnitude of the deviation. The black square has an area equal to the average area of all the squares. Its sides have a length equal to the standard deviation, the square root of variance.\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n::: {.cell-output-display}\n![Visualizing Variance.<br>The values of variable *X* are plotted with the deviations of *X*. Each square is a deviation from the mean of *X*. Darker squares have larger deviations. The area of the thick black square is the variance&mdash;the average size of the squared deviations.](descriptives_files/figure-html/fig-variancevisualization-1.png){#fig-variancevisualization fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" button_before='true' button_after='true' codelabel='R Code'}\n:::{.callout-note collapse=\"true\" appearance=\"minimal\"}\n## R Code for @fig-variancevisualization\n\n```{.r .cell-code}\n# Visualizing Variance\n\nset.seed(1)\nx <- rnorm(70, 10, 3)\nmu <- mean(x)\nsigma <- sd(x)\nxbreaks <- pretty(x)\nybreaks <- pretty(x - mu)\n\ntick_width <- .04 * sigma\n\ntibble(x = x,\n       deviations = x - mu,\n       abval = abs(deviations)) |>\n  arrange(-abval) |>\n  ggplot(aes(x, deviations)) +\n  geom_rect(\n    aes(\n      xmax = x,\n      xmin = mu,\n      ymax = deviations,\n      ymin = 0,\n      fill = deviations\n    ),\n    color = \"gray95\",\n    linewidth = .1\n  ) +\n  annotate(\n    \"segment\",\n    yend = max(ybreaks) + tick_width,\n    y = min(ybreaks) - tick_width,\n    x = mu,\n    xend = mu,\n    color = \"gray30\"\n  ) +\n  annotate(\n    \"segment\",\n    xend = max(xbreaks) + tick_width,\n    x = min(xbreaks) - tick_width,\n    y = 0,\n    yend = 0,\n    color = \"gray30\"\n  ) +\n  coord_equal() +\n  annotate(\n    \"rect\",\n    xmax = mu + sigma,\n    xmin = mu,\n    ymax = sigma,\n    ymin = 0,\n    fill = NA,\n    color = \"gray10\",\n    linewidth = 1\n  ) + \n  annotate(\n    \"richtext\",\n    x = mu + sigma / 2,\n    y = sigma,\n    label = paste0(\"*\",span_style(\"&sigma;\"),\"* = \", \n                   scales::number(sigma, accuracy = .01)),\n    label.color = NA,\n    fill = NA,\n    vjust = 0,\n    family = bfont,\n    size = ggtext_size(16),\n    color = \"gray20\"\n  ) + \n  annotate(\n    \"richtext\",\n    x = mu + sigma,\n    y = sigma / 2,\n    angle = 90,\n    label = paste0(\"*\",span_style(\"&sigma;\"),\"* = \", \n                   scales::number(sigma, accuracy = .01)),\n    label.color = NA,\n    fill = NA,\n    vjust = 1.1,\n    family = bfont,\n    size = ggtext_size(16),\n    color = \"gray20\"\n  ) +\n  geom_richtext(\n    data = tibble(\n      x = xbreaks,\n      deviations = 0,\n      vjust = ifelse(xbreaks < mu, 0, 1.05)\n    ),\n    aes(label = x, vjust = vjust),\n    family = bfont,\n    label.color = NA,\n    label.padding = unit(c(.2, 0, .2, 0), \"lines\"),\n    fill = NA,\n    size = ggtext_size(16),\n    color = \"gray20\"\n  ) +\n  geom_richtext(\n    data = tibble(\n      deviations = ybreaks,\n      x = mu,\n      hjust = ifelse(ybreaks < 0, 0, 1.05)\n    ) |>\n      dplyr::filter(deviations != 0),\n    aes(\n      label = signs::signs(deviations, accuracy = 1),\n      hjust = hjust\n    ),\n    family = bfont,\n    label.color = NA,\n    fill = NA,\n    label.padding = unit(c(0, .4, 0, .4), \"lines\"),\n    size = ggtext_size(16),\n    color = \"gray20\"\n  ) + annotate(\"point\",\n               x = mu,\n               y = 0,\n               size = 3) +\n  annotate(\n    \"richtext\",\n    x = mu,\n    y = 0,\n    label = paste0(\n      \"*\",\n      span_style(\"&mu;\"),\n      \"* = \",\n      scales::number(mu, accuracy = .01),\n      \"\"\n    ),\n    label.color = NA,\n    fill = NA,\n    vjust = 0.5,\n    hjust = -.1,\n    angle = -45,\n    family = bfont,\n    size = ggtext_size(bsize),\n    color = \"gray20\"\n  ) +\n  geom_segment(\n    data = tibble(x = xbreaks),\n    aes(\n      x = xbreaks,\n      y = tick_width,\n      yend = -tick_width,\n      xend = xbreaks\n    ),\n    color = \"gray20\"\n  ) +\n  geom_segment(\n    data = tibble(y = ybreaks) |> dplyr::filter(y != 0),\n    aes(\n      y = y,\n      x = mu + tick_width,\n      xend = mu - tick_width,\n      yend = y\n    ),\n    color = \"gray20\"\n  ) +\n  theme_void(base_family = bfont, base_size = bsize) +\n  theme(legend.position = \"right\",\n        legend.title = element_text(angle = 90, \n                                    margin = margin(l = -15, r = -24))) +\n  scale_fill_gradient2(\n    \"Deviations\",\n    midpoint = 0,\n    low = myfills[1],\n    high = myfills[2],\n    mid = \"white\",\n    breaks = ybreaks,\n    limits = c(-8, 8),\n    labels = \\(x) signs(x, accuracy = 1)\n  ) +\n  guides(\n    fill = guide_colorbar(\n      title = \"Deviations\",\n      label.position = \"right\",\n      title.position = \"left\",\n      title.hjust = 0.5,\n      direction = \"vertical\",\n      barheight = unit(.9, \"npc\")\n    )\n  ) +\n  annotate(\n    \"text\",\n    x = min(xbreaks) - tick_width * 4,\n    y = 0,\n    label = \"X\",\n    family = bfont,\n    color = \"gray20\",\n    fontface = \"italic\",\n    size = ggtext_size(bsize, 1)\n  ) + \n  annotate(\"richtext\",\n           label.color = NA,\n           fill = NA,\n           x = mu + sigma / 2,\n           y = sigma / 2,\n           vjust = 0.5,\n           size = ggtext_size(bsize),\n           label = paste0(\"*\", \n                          span_style(\"&sigma;\"), \n                          \"*<sup>2</sup> = \", \n                          scales::number(sigma ^ 2, accuracy = .01)),\n           family = bfont,\n           color = \"gray20\") +\n  geom_point(pch = 16, size = 1.7, color = \"black\", y = 0, alpha = .8) \n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Standard Deviation\n\nThe [standard deviation]{.defword title=\"The **standard deviation** is a measure of variabily that estimates the typical distance of a score from its own mean.\"} is by far the most common measure of variability. The standard deviation $\\sigma$ is the square root of the variance $\\sigma^2$.\n\n$$\n\\begin{aligned}\n\\sigma&=\\sqrt{\\sigma^2}=\\sqrt{\\frac{\\sum_i^n{\\left(x_i-\\mu\\right)^2}}{n}}\\\\\ns&=\\sqrt{s^2}=\\sqrt{\\frac{\\sum_i^n{\\left(x_i-m\\right)^2}}{n-1}}\n\\end{aligned}\n$$\n\n\n\n\nAlthough it is not an arithmetic average of the deviations, it can be thought of as representing the typical size of the deviations. Technically, it is the square root of the average squared deviation.\n\nIn a normal distribution, the standard deviation is the distance from the mean to the two [inflection points]{.defword title=\"An **inflection point** in a curve is the point at which the curvature changes from upward to downward or vice versa.\"} in the probability density curve (see @fig-normalinflection).\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n::: {.cell-output-display}\n![The inflection points in the normal curve are 1 standard deviation from the mean.](descriptives_files/figure-html/fig-normalinflection-1.png){#fig-normalinflection fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" button_before='true' button_after='true' codelabel='R Code'}\n:::{.callout-note collapse=\"true\" appearance=\"minimal\"}\n## R Code for @fig-normalinflection\n\n```{.r .cell-code}\n# The inflection points in the normal curve \n# are 1 standard deviation from the mean.\n\nd_text <- tibble(x = c(-1, 1,-1.4, 1.4, -.65,.65),\n                 y = dnorm(x),\n                 angle = c(0,0,68,-68, 67,-67),\n                 hjust = c(1,0,rep(.5, 4)),\n                 vjust = c(0.5,0.5, 0.1, 0.1, 0.05, 0.05),\n                 label = c(paste0(\"Inflection point at &minus;1<em>\", span_style(\"&sigma;\"), \"</em>\"),\n                           paste0(\"Inflection point at +1<em>\", span_style(\"&sigma;\"), \"</em>\"),\n                           \"Upward curve\",\n                           \"Upward curve\",\n                           \"Downward curve\",\n                           \"Downward curve\"),\n                 color = c(\"black\", \"black\", myfills[1], myfills[1], myfills[2], myfills[2])\n                 )\n\nggplot(tibble(x = c(-4,4)), aes(x)) + \n  stat_function(fun = dnorm, geom = \"area\", alpha = 0.4, fill = myfills[1], xlim = c(-4,-1)) +\n  stat_function(fun = dnorm, geom = \"area\", alpha = 0.4, fill = myfills[2], xlim = c(-1,1)) +\n  stat_function(fun = dnorm, geom = \"area\", alpha = 0.4, fill = myfills[1], xlim = c(1,4)) +\n  annotate(x = c(-1,1), y = dnorm(c(-1,1)), geom = \"point\") + \n  geom_richlabel(aes(color = color, label = label, y = y, angle = angle, hjust = hjust, vjust = vjust), data = d_text, text_size = 18) + \n  scale_color_identity() +\n  scale_x_continuous(\"Standard Deviation Units\", \n                     breaks = -4:4, \n                     labels = paste0(signs::signs(-4:4, \n                                                  accuracy = 1, \n                                                  label_at_zero = \"blank\", \n                                                  add_plusses = T),\n                                     \"<em>\",\n                                     span_style(c(rep(\"&sigma;\", 4), \"&mu;\", rep(\"&sigma;\", 4))), \n                                     \"</em>\")) +\n  scale_y_continuous(NULL, breaks = NULL, limits = c(0,NA), expand = expansion()) +\n  coord_fixed(12)  +\n  geom_vline(xintercept = 0, color = \"gray30\") +\n  theme(panel.grid = element_blank(), \n        axis.text.x = element_markdown())\n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Average Absolute Deviations\n\nAverage absolute deviations summarize the absolution values of deviations from a central tendency measure. There are many kinds of average absolute deviations, depending which central tendency each value deviates from and then which measure of central tendency summarizes the absolute deviations. With three central tendency measures, we can imagine nine different \"average\" absolute deviations:\n\n$$\\text{The}~\\begin{bmatrix}mean\\\\ median\\\\ modal\\end{bmatrix}~\\text{absolute deviation around the}~\\begin{bmatrix}mean\\\\ median\\\\ mode\\end{bmatrix}.$$\n\nThat said, two of these average absolute values are used more than the others: the median deviation around the median and mean deviation around the mean. One struggles to imagine what uses one might have for the others (e.g, the modal absolute deviation around the median or the mean absolute deviation around the mode).\n\n#### Median Absolute Deviation (around the Median)\n\n\n\nSuppose that we have a random variable $X$, which has a median of $\\tilde{X}$. The median absolute deviation (MAD) is the median of the absolute values of the deviations from the median:\n\n$$\n\\text{Median Absolute Deviation (around the Median)}=\\mathrm{median}\\left(\\left|X-\\tilde{X}\\right|\\right)\n$$\n\nA primary advantage of the MAD over the standard deviation is that it is robust to the presence of outliers. For symmetric distributions, the MAD is half the distance of the interquartile range.\n\n#### Mean Absolute Deviation (around the Mean)\n\nIf the mean of random variable $X$ is $\\mu_X$, then:\n\n$$\n\\text{Mean Absolute Deviation (around the Mean)}=\\mathrm{mean}\\left(\\left|X-\\mu_X\\right|\\right)\n$$\n\nThe primary advantage of this statistic is that it is easy to explain to people with no statistical training. In a straightforward manner, it tells us how far each score is from the mean, on average. \n\n## Skewness\n\n(Unfinished)\n\n## Kurtosis\n\n(Unfinished)\n\n\n# Moments, Cumulants, and Descriptive Statistics\n\nWe can define random variables in terms of their probability mass/density functions. We can also define them in terms of their moments and cumulants.\n\n## Raw Moments\n\nThe first raw moment $\\mu'_1$ of a random variable $X$ is its expected value:\n\n$$\\mu'_1=\\mathcal{E}(X)=\\mu_X$$\n\nThe second raw moment $\\mu'_2$ is the expected value of $X^2$:\n\n$$\\mu'_2=\\mathcal{E}(X^2)$$\n\nThe $n$th raw moment $\\mu'_n$ is the expected value of $X^n$:\n\n$$\\mu'_n=\\mathcal{E}(X^n)$$\n\n\n\n## Central Moments\n\nThe first raw moment, the mean, has obvious significance and is easy to understand. The remaining raw moments do not lend themselves to easy interpretation. We would like to understand the higher moments after accounting for the lower moments. For this reason, we can discuss central moments, which are like raw moments after subtracting mean.\n\nOne can evaluate a moment \"about\" a constant $c$ like so:^[Alternately, we can say that this is the $n$th moment *referred to* $c$.]\n\n$$\n\\text{The }n\\text{th moment of }X\\text{ about }c=\\mathcal{E}\\left(\\left(X-c\\right)^n\\right)\n$$\n\n\n\nA [central moment]{.defword title=\"A **central moment** is a raw moment after the variable's mean has been subracted.\"} $\\mu_n$ is a moment about the mean (i.e., the first raw moment):\n\n$$\n\\mu_n=\\mathcal{E}\\left(\\left(X-\\mu_X\\right)^n\\right)\n$$\n\nThe first central moment $\\mu_1$ is not very interesting, because it always equals 0:\n\n$$\n\\begin{aligned}\\mu_1&=\\mathcal{E}\\left(\\left(X-\\mu_X\\right)^1\\right)\\\\\n&=\\mathcal{E}\\left(\\left(X-\\mu_X\\right)\\right)\\\\\n&=\\mathcal{E}\\left(X\\right)-\\mathcal{E}\\left(\\mu_X\\right)\\\\\n&=\\mu_X-\\mu_X\\\\\n&=0\n\\end{aligned}\n$$\n\nOf note, the second central moment $\\mu_2$ is the variance:\n\n$$\n\\mu_2=\\mathcal{E}\\left(\\left(X-\\mu_X\\right)^2\\right)=\\sigma_X^2\n$$\n\n## Standardized Moments\n\nA standardized moment^[Standardized moments are also called *normalized central moments*.] is the raw moment of a variable after it has been \"standardized\" (i.e., converted to a *z*-score):\n\n:::{.column-margin}\nStandardizing a variable by converting it to *z*-score is accomplished like so:\n$$\nz=\\frac{X-\\mu_X}{\\sigma_X}\n$$\n:::\n\n$$\n\\text{The }n\\text{th standardized moment} = \\mathcal{E}\\left(\\left(\\frac{X-\\mu_X}{\\sigma_X}\\right)^n\\right)=\\frac{\\mu_n}{\\sigma^n}\n$$\n\nThe first two standardized moments have little use because they are always the same for every variable. The first standardized moment is the expected value of a z-score, which is always 0.\n\n$$\n\\mathcal{E}\\left(\\left(\\frac{X-\\mu_X}{\\sigma_X}\\right)^1\\right)=\\mathcal{E}\\left(z\\right) = 0\n$$\nThe second standardized moment is the expected value of a z-score squared, which is always 1.\n\n$$\n\\mathcal{E}\\left(\\left(\\frac{X-\\mu_X}{\\sigma_X}\\right)^2\\right)=\\frac{\\mathcal{E}\\left(\\left(X-\\mu_X\\right)^2\\right)}{\\sigma_X^2} =\\frac{\\sigma_X^2}{\\sigma_X^2}= 1\n$$\n\nThe third standardized moment is the expected value of a z-score cubed, which is one an important measure of skewness.\n\nThe idea that skewness is the third standardized moment (i.e., the expected value of the z-score cubed) allows for an interesting intrepretation of skewness. To begin, the z-score by itself is a measure of the overall level of the score. The z-score squared is a measure of variability. Thus, skewness can be seen as the relationship between deviation and variability.\n\n$$\n\\mathcal{E}\\left(z^3\\right) = \\mathcal{E}\\left(\\underbrace{z}_{\\text{Level}}\\cdot \\underbrace{z^2}_{\\text{Variability}}\\right)\n$$\n\nThus a positively skewed variable can be described having a tendency to be become more variable (more sparse) as its value increases.\n\n\n\n\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\"}\n::: {.cell-output-display}\n![Positive skewness can be interpeted as a tendency for the data to become more sparse as the scores increase.](descriptives_files/figure-html/fig-skewnessinterpretation-1.png){#fig-skewnessinterpretation fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell .fig-cap-location-margin .tbl-cap-location-margin layout-align=\"center\" button_before='true' button_after='true' codelabel='R Code'}\n:::{.callout-note collapse=\"true\" appearance=\"minimal\"}\n## R Code for @fig-skewnessinterpretation\n\n```{.r .cell-code}\ntibble(x = seq(0, 15, .01), y = dchisq(x, 3)) %>%\n  ggplot(aes(x, y)) +\n  geom_area(fill = myfills[1]) +\n  theme_void() +\n  coord_fixed(30) +\n  annotate(\n    \"segment\",\n    x = 3,\n    y = 0,\n    xend = 3,\n    yend = dchisq(3, 3) + .01,\n    color = \"white\"\n  ) +\n  geom_arrow(\n    data = tibble(x = c(3, 0), y = c(0.01, 0.01)),\n    arrow_head =  arrow_head_deltoid(),\n    color = \"white\",\n    resect = 1\n  ) +\n  geom_arrow(\n    data = tibble(x = c(3, 8), y = c(0.01, 0.01)),\n    arrow_head =  arrow_head_deltoid(),\n    color = \"white\",\n    resect = 1\n  ) +\n  geom_richtext(\n    data = tibble(\n      x = 3,\n      y = .01,\n      l = c(\"Lower Values<br>Less Sparse\", \"Higher Values<br>More Sparse\"),\n      hj = c(1,0)\n    ),\n    aes(label = l, hjust = hj),\n    vjust = 0,\n    fill = NA,\n    color = \"white\",\n    label.color = NA,\n    size = ggtext_size(16),\n    label.padding = margin(r = 6, l = 6, b = 3.5)\n  ) +\n  geom_richtext(\n    data = tibble(x = 3, y = 0, l = c(\"Mean\")),\n    aes(label = l),\n    vjust = 1,\n    label.color = NA,\n    size = ggtext_size(16),\n    color = myfills[1]\n  ) +\n  geom_blank(data = tibble(x = 0, y = -.02))\n```\n\n\n:::\n:::\n",
    "supporting": [
      "descriptives_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}